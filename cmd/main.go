package main

import (
	"context"
	"database/sql"
	"flag"
	"fmt"

	"github.com/go-kit/kit/log"
	"github.com/go-kit/kit/log/level"
	_ "github.com/lib/pq"

	"net/http"
	"os"

	"github.com/rjjp5294/accountsrv"
)

/*According to Go-Kit docs, the main func should be a bit hefty since it is meant
to "set the stage" for the application in terms of control of component lifecycles
and scoping dependency injections here in one place:

"Inversion of control is a common feature of other frameworks, implemented via
Dependency Injection or Service Locator patterns. But in Go kit, you should wire
up your entire component graph in your func main. This style reinforces two important
virtues. By strictly keeping component lifecycles in main, you avoid leaning on global
state as a shortcut, which is critical for testability. And if components are scoped
to main, the only way to provide them as dependencies to other components is to pass
them explicitly as parameters to constructors. This keeps dependencies explicit, which
stops a lot of technical debt before it starts."

Notice how the main function "assembles" the components, utilizing factory functions
to initialize a component and then passing in that initialized component as a parameter to
create another component. This is a great way to implement Dependency Injection and
enforce a clean, swap-able of building our service where changes can be made in just one place.
E.g. swapping a DB from SQL to Mongo can easily be achieved by simply re-writing the
interface/implementations dealing with the DB, then coming here to change how we connect to the DB
and how we initialize the DB component and we are done.
*/

// URI for out postgres db
const dbsource = "postgresql://ricardopineda:@localhost:5432/gokitexample?sslmode=disable"

func main() {
	// Define the command line flag for the port we want to run the http service on. This returns a pointer to the
	// string when flag.Parse() is called.
	var httpAddr = flag.String("http", ":8080", "http listen address")

	var logger log.Logger
	{
		// Wrap the Stderr (our io Writer) with NewLogfmtLogger to enable key value type logging
		logger = log.NewLogfmtLogger(os.Stderr)
		// Wrap logger in NewSyncLogger to enable synchronized logging across concurrent goroutines
		// using the same logger
		logger = log.NewSyncLogger(logger)
		// Sets up some useful metadata to print with logs generated by this logger
		logger = log.With(logger,
			"service", "account",
			"time", log.DefaultTimestampUTC,
			"caller", log.DefaultCaller,
		)
	}

	// Create an info level log on the service starting up
	level.Info(logger).Log("msg", "service started")
	// Defer an info log to notify the service ended when the function terminates
	defer level.Info(logger).Log("msg", "service ended")

	// Setting up the DB connection
	var db *sql.DB // is a POINTER to the db
	{
		var err error
		db, err = sql.Open("postgres", dbsource)
		// On error connecting to DB, log error and exit the process
		if err != nil {
			level.Error(logger).Log("exit", err)
			os.Exit(-1)
		}
	}

	// Parse the flags passed in from command line
	flag.Parse()
	// Init a context for the process, this one being special in that it is empty,
	// non-nil, never cancels, no deadline and has no values.
	ctx := context.Background()

	// Define a variable for the account service
	var accountService accountsrv.Service
	// Below are perfect examples of clean dependency injection in a centrally scoped place
	// using factory funcs
	{
		// Initialize Repository interface && underlying struct using the NewRepo factory func
		repository := accountsrv.NewRepo(db, logger)

		// Initialize the account service using the factory func, passing in the repository
		// instance we just created along with the logger we defined above.
		accountService = accountsrv.NewService(repository, logger)
	}

	// Create a channel for errors
	errs := make(chan error)

	// Again, using a factory function to create the Endpoints and passing in the
	// service we initialized about as a dependency and central scope control
	endpoints := accountsrv.MakeEndpoints(accountService)

	// Spin up the server in a goroutine
	go func() {
		fmt.Println("listening on port", *httpAddr)
		// Initialize a server instance using the Background Context and Endpoints we
		// defined above, injecting the dependencies directly
		handler := accountsrv.NewHTTPServer(ctx, endpoints)
		// Start the server, pipe errors (if any) resulting from this into the errs channel
		errs <- http.ListenAndServe(*httpAddr, handler)
	}()

	// Log errors from the errs channel
	level.Error(logger).Log("exit", <-errs)
}
